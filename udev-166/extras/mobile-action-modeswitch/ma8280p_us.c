/* http://www.natox.be/ma8280p/
 * http://www.leopold.dk/~martin/ma-8230p.html
 * http://figvam.blogspot.com/2007/01/mobile-action-8730p-usb-cable-and-linux.html
 */

/*
 *
 * Code by davy hollevoet. This is simply an adaptation of code
 * generated by usbsnoop2libusb. (http://iki.fi/lindi/usb/usbsnoop2libusb.pl)
 *
 * This code is released under both the GPL version 2 and BSD licenses.
 * Either license may be used.
 *
 * GPLv2
 * ********
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * In addition:
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * BSD
 * ******
 * Copyright (c) 1998, Regents of the University of California
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the University of California, Berkeley nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* This file is (mostly) generated with usbsnoop2libusb.pl from a usbsnoop log file. */
/* Latest version of the script should be in http://iki.fi/lindi/usb/usbsnoop2libusb.pl */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <signal.h>
#include <ctype.h>
#include <time.h>
#include <usb.h>

#include "utils.h"
#include "ma8280p_us.h"

static void msleep(long msec)
{
	struct timespec duration = { 0, msec * 1000 * 1000 };

	nanosleep(&duration, NULL);
}

int ma8280p_switch (struct usb_dev_handle *devh, struct usb_device *dev)
{
	int ret = 1;
	char *buf = NULL;

	buf = malloc (65535);
	if (!buf) {
		error ("%s: not enough memory", dev->filename, ret);
		return -1;
	}

	usb_get_descriptor(devh, 0x0000001, 0x0000000, buf, 0x0000012);
	msleep(6);
	usb_get_descriptor(devh, 0x0000001, 0x0000000, buf, 0x0000012);
	msleep(6);
	usb_get_descriptor(devh, 0x0000002, 0x0000000, buf, 0x0000400);
	msleep(10);
	ret = usb_release_interface(devh, 0);
	if (ret != 0) 
		debug ("%s: failed to release interface before set_configuration: %d", dev->filename, ret);
	usb_set_configuration(devh, 0x0000001);
	ret = usb_claim_interface(devh, 0);
	if (ret != 0) 
		debug ("%s: claim after set_configuration failed with error %d", dev->filename, ret);
	//usb_set_altinterface(devh, 0);
	//msleep(33);
	usb_control_msg(devh, USB_TYPE_CLASS + USB_RECIP_INTERFACE + USB_ENDPOINT_IN, 0x0000001, 0x0000300, 0x0000000, buf, 0x0000008, 1000);
	msleep(5);
	memcpy(buf, "\xb0\x04\x00\x00\x02\x90\x26\x86", 0x0000008);
	usb_control_msg(devh, USB_TYPE_CLASS + USB_RECIP_INTERFACE, 0x0000009, 0x0000300, 0x0000000, buf, 0x0000008, 1000);
	msleep(4);
	memcpy(buf, "\xb0\x04\x00\x00\x02\x90\x26\x86", 0x0000008);
	usb_control_msg(devh, USB_TYPE_CLASS + USB_RECIP_INTERFACE, 0x0000009, 0x0000300, 0x0000000, buf, 0x0000008, 1000);
	msleep(4);

	msleep(4);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(6);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(1);
	//URB_FUNCTION_GET_STATUS_FROM_ENDPOINT skipped
	msleep(4);
	memcpy(buf, "\x37\x01\xfe\xdb\xc1\x33\x1f\x83", 0x0000008);
	usb_interrupt_write(devh, 0x00000002, buf, 0x0000008, 1000);
	msleep(3);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(1);
	memcpy(buf, "\x37\x0e\xb5\x9d\x3b\x8a\x91\x51", 0x0000008);
	usb_interrupt_write(devh, 0x00000002, buf, 0x0000008, 1000);
	msleep(7);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(1);
	memcpy(buf, "\x34\x87\xba\x0d\xfc\x8a\x91\x51", 0x0000008);
	usb_interrupt_write(devh, 0x00000002, buf, 0x0000008, 1000);
	msleep(7);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(2);
	//URB_FUNCTION_GET_STATUS_FROM_ENDPOINT skipped
	msleep(4);
	memcpy(buf, "\x37\x01\xfe\xdb\xc1\x33\x1f\x83", 0x0000008);
	usb_interrupt_write(devh, 0x00000002, buf, 0x0000008, 1000);
	msleep(2);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(1);
	memcpy(buf, "\x37\x0e\xb5\x9d\x3b\x8a\x91\x51", 0x0000008);
	usb_interrupt_write(devh, 0x00000002, buf, 0x0000008, 1000);
	msleep(7);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(1);
	memcpy(buf, "\x34\x87\xba\x0d\xfc\x8a\x91\x51", 0x0000008);
	usb_interrupt_write(devh, 0x00000002, buf, 0x0000008, 1000);
	msleep(7);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(8);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(1);
	//URB_FUNCTION_GET_STATUS_FROM_ENDPOINT skipped
	msleep(4);
	memcpy(buf, "\x33\x04\xfe\x00\xf4\x6c\x1f\xf0", 0x0000008);
	usb_interrupt_write(devh, 0x00000002, buf, 0x0000008, 1000);
	msleep(3);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);
	msleep(1);
	//URB_FUNCTION_GET_STATUS_FROM_ENDPOINT skipped
	msleep(4);
	memcpy(buf, "\x32\x07\xfe\xf0\x29\xb9\x3a\xf0", 0x0000008);
	usb_interrupt_write(devh, 0x00000002, buf, 0x0000008, 1000);
	msleep(3);
	usb_interrupt_read(devh, 0x00000081, buf, 0x0000008, 1000);

	if (buf)
		free (buf);
	return 0;
}
